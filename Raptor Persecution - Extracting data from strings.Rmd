---
title: "Raptor Persecution Extracting Organised Data From Strings"
author: "Matthew Whittle"
date: "14/09/2019"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
```
```{r include = FALSE}
require(tidyverse)
require(sf)
require(kableExtra)
```
# Introduction


- `tidyverse` Specifically the sub-package `stringr` for manipulating text.
- `sf` For reading in the data as a shapefile



```{r message FALSE}
data <- st_read("data/rspb/Raptor Persecution - Original Dataset.shp")
```
```{r}
data %>% as_tibble()
```
The dataset contains information on the species persecuted in each observation in the `Details` column. Lets take a look at the first six observations with the `$` operator and the `head()` function.
```{r}
data$Details %>% head()
```
## Regular expressions and string functions
It looks like this column may contain some interesting data but it's going to take some work to get it in a useful format. To do so we will need to mnipulate the column using regular expressions (regex for short). A regex allows you to match strings using special characters (sometimes called wildcards in other software packages). Regex is a pretty big subject and beyond the scope of this tutorial. The section on it in [R for Data Science](https://r4ds.had.co.nz/strings.html#matching-patterns-with-regular-expressions) is a pretty good introduction.

We'll use functions from the `stringr` package to extract, remove and split strings. Most functions in this package take a string argument (our `Details` variable) and a pattern argument (our regex). 
### Quick example using `str_view`
For example, We can extract all digits within the `Details` variable using the regex `[0-9]+`. FYI - `str_view`and `str_view_all` allow you to view what you are matching within a string.
```{r}
string <- "Species targeted: Birds of prey. Species involved: Raven x 1. Tested positive for: Carbofuran."
str_view_all(string = string, pattern = "[0-9]+")
```
We can match every character string with the regex `[A-za-z]+`.
```{r}
string <- "Species targeted: Birds of prey. Species involved: Raven x 1. Tested positive for: Carbofuran."
str_view_all(string = string, pattern = "[A-za-z]+")
```
## Extracting data on the species targeted
Using regular expressions is an iterative process, requiring a number of attempts to get what you want. Instead of writing a really complicated regex, it's worth trying to split it into a few steps with each performing a specific action.

The `Details` variable begins with the text "Species involved:" or "Species targeted:" followed by the species name (sometimes with multiple species) and the further details about the incident. 

Firstly, we're going to convert the string entirely to lower case using `mutate` and `str_to_lower`. This is because upper case tends to complicate matters if text has been inconsistently capitalised.
```{r}
data <- data %>% mutate(Details = Details %>% str_to_lower())
```
We're going to specify the patterns in objects. This will allow me to call them repeatedly and edit them in one place. Lets try match the species bit first. The `|` character is an or operator. In the example below it means "involed" or "targeted". The brackets specify that it is only "involed" or "targeted" that | should opeate on, not the whole string.
```{r}
species_invtarg <- "species (involved|targeted)"
data$Details %>% head() %>% str_extract(species_invtarg)
```
Are there any that this regex doesn't match? By adding `is.na` on the end of our function chain we can test for missing values. This returns a logical vector that can be used inside square brackets to subset the variable to observations not picked up by the regex. We could also do this by calling `str_detect` with our regex pattern and taking the inverse of the logical vector.
```{r}
data$Details[data$Details %>% str_extract(species_invtarg) %>% is.na()]
```
Looks like theres a spelling mistake in the data. We can modify the regex to account for this using brackets and the | (or) operator on the end of species to specify species ending in an 's' or a 'd' - `"specie(s|d)"`. 
```{r}
species_invtarg <- "specie(s|d) (involved|targeted)"
data$Details[data$Details %>% str_extract(species_invtarg) %>% is.na()] # Should return an empty vector because everything has been matched.
data$Details %>% head() %>% str_extract(species_invtarg)
```
Next lets design a regex to specify the additional detail at the end of the string. We can either use this to remove it or extract it into another variable. We'll use the `.` character which matches any character and the `+` operator which means one or many. Put together they match one or many of any character. Adding them onto part of a string will match that part and anything after it.
```{r}
data$Details %>% head()
poison_string <- "(tested|poison|possession).+"
data$Details %>% head() %>% str_extract(poison_string)
```
Now we'll use both patterns in succession to remove the leading and trailing strings. 
```{r}
species <- 
  data$Details %>% 
  str_remove_all(species_invtarg) %>% 
  str_remove_all(poison_string) 
head(species)
```
Now we have another problem. There are multiple species within each string, with a delimiter of `:`, `,` or `;`. we're going to use the function `str_split` to split the string into multiple elements using a pattern to match the delimiter. we'll test it on this string `": goshawk x 1; buzzard x 4; peregrine x 1.; undisclosed bait x 1"`.
```{r}
delimiter <- ":|;|,"

x <- ": goshawk x 1; buzzard x 4; peregrine x 1.; undisclosed bait x 1"

elements <- x %>% str_split(delimiter) %>% unlist()
# Remove null element
elements <- elements[!(elements == "")]
print(elements)

# Remove any bait elements
elements <- elements[!elements %>% str_detect("bait")]
print(elements)
```
The string also contains useful information about the count of each species involved in each incident. This may yield some valuable insight so it is worth extracting. Using the regex `[0-9]+` we'll extract the digits from each element, then remove that from the string.
```{r}
species_name <-
  elements %>% str_remove_all("x [0-9]+|\\.") %>% trimws()

count <- elements %>% str_extract("[0-9]+") %>% parse_number()
count[is.na(count)] <- 1

map2(.x = species_name, .y = count, ~ rep(.x, .y)) %>% unlist() %>% paste0(collapse = ", ")
```
Now we need to wrap this up into a function that will apply this method to every string in the `Details` variable. Here we're using `map` to apply the process above to each element of the vector. You can understand the code below as passing each element of the species vector via map to an annonymous function. Within the anonymous function the element is referred to as the object `x`.
```{r}
species_tidy <-
  species %>%
  map( ~ .x %>%
         (function(x) {
           delimiter <- ":|;|,"
           
           
           elements <- x %>% str_split(delimiter) %>% unlist() %>% trimws()
           elements <- elements[!(elements == "")]
           elements <- elements[!elements %>% str_detect("bait")]
           species_name <-
             elements %>% str_remove_all("x [0-9]+|\\.") %>% trimws()
           
           count <- elements %>% str_extract("[0-9]+") %>% parse_number()
           count[is.na(count)] <- 1
           
           
           map2(.x = species_name, .y = count, ~ rep(.x, .y)) %>% unlist() %>% paste0(collapse = ", ")
           
         })) %>% unlist()


head(species_tidy)
```
Finally we'll add the tidy data back into the dataset as a new variable `species_targeted`.
```{r}
data <- 
  data %>%
  mutate(species_targeted = species_tidy)
```
## Extracting data on the poison used
Now let's focus on the part of the string that holds detail about the poison used. We'll use the pattern `"tested positive for:.+"` which will collect this string and anything following it. 
```{r}
poison_data <- data$Details %>% str_extract("tested positive for:.+")
```
To extract the poison type data we're going to take a slightly more longhand approach. By making a table of all words, we can see that there are only a few words that need to be removed from the data to reduce it down to just poison types. Instead of writing a complicated regex to extract everything that looks like a poison type, it will be much easier to just remove the words and punctuation that isn't needed. This approach won't gerenalise as well to new data but is a quick way of getting the job done.

```{r echo = FALSE,fig.width = 5, fig.align= "center"}
poison_data %>% str_remove_all("[[:punct:]]") %>% str_split(" ") %>% unlist() %>% table(dnn = c("Word")) %>% (function(x){
  x[order(x,decreasing = TRUE)]
  
}) %>% kable()%>% kable_styling(position = "center", full_width = TRUE) %>% scroll_box(height = "250px",width = "300px") 
```

The code below captures each unwanted word as an element of the vector `non_poison_tokens`. This vector is then collapsed into one string with `|` between each word. This string can be used as a regex to detect and remove any of the unwanted words within a string.
```{r}
non_poison_tokens <- # Create a vecto of unwanted words (tokens)
  c("also", "bird", "for", "found", "only", "tested", "stored", "positive")

non_poison_regex <-  # Collapse them into a regex using the paste function and the 'or' operator.
  non_poison_tokens %>%
                   paste0(collapse = "|")

poison_data_tidy <- 
  poison_data %>% 
  str_remove_all("[[:punct:]]")  %>% # Remove punctuation
  str_remove_all(non_poison_regex) %>% # Remove any of the unwanted words that are detected
  trimws() %>% # Remove leading or trailing white space
  str_replace_all(" ", ", ") # Add in a comma as a delimiter for consistency with species data and easy splitting later.

head(poison_data_tidy)
data <- data %>% mutate(poison_used = poison_data_tidy)
```
# Summary
